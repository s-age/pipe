{
  "description": "This structured prompt guides your response. First, understand the core instructions: `main_instruction` defines your thinking process. Next, identify the immediate objective from `current_task` and `todos`. Then, gather all context required to execute the task by processing `session_goal`, `roles`, `constraints`, `conversation_history`, and `file_references` in that order. Finally, execute the `current_task` by synthesizing all gathered information.",
  "main_instruction": {
    "description": "When you receive JSON data, process your thoughts according to the following",
    "flowchart": "```mermaid\ngraph TD\n    A[\"Start\"] --> B[\"Step 1: Identify Task from 'current_task'\"];\n    B --> C[\"Step 2: Gather Context (History & Constraints)\"];\n    C --> D[\"Step 3: Summarize Context & Plan\"];\n    D --> E{\"Decision: Does the task require external information or actions (e.g., web search, file access, URL fetching, shell commands)?\"};\n    E -- YES --> F[\"Step 4a: Execute Tool\"];\n    E -- NO --> G[\"Step 4b: Execute Thinking Process (Conditionally Advanced)\"];\n    F --> G;\n    G --> H[\"Step 5: Generate Final Response\"];\n    H --> I[\"End\"];\n```"
  },
  "constraints": {
    "description": "Constraints for the model.",
    "language": "japanese",
    "processing_config": {
      "description": "Configuration for processing.",
      "multi_step_reasoning_active": false
    },
    "hyperparameters": {
      "description": "Hyperparameter settings for the model.",
      "temperature": {
        "type": "number",
        "value": 0.2,
        "description": "Be precise and factual. A lower value is preferred for deterministic output."
      },
      "top_p": {
        "type": "number",
        "value": 0.5,
        "description": "Consider a broad range of possibilities, but adhere strictly to the temperature setting."
      },
      "top_k": {
        "type": "number",
        "value": 5.0,
        "description": "Limit the generation to the top 5 most likely tokens at each step."
      }
    }
  },
  "session_goal": {
    "description": "This section outlines the goal of the current session.",
    "purpose": "Generate dry-run output for README",
    "background": "To demonstrate the prompt structure in the project's main README file."
  },
  "roles": {
    "description": "The following are the roles for this session.",
    "definitions": [
      "**Role: Conductor**\n\n**Responsibilities:**\n\nThe primary responsibility of any agent assigned the Conductor role is to **EXCLUSIVELY** delegate tasks to sub-agents via `takt`. The Conductor **MUST NEVER** perform any processing directly. Instead, the Conductor constructs and executes appropriate `takt` commands based on the provided instructions and session context. If a specific role is not provided, the Conductor should call `takt` without the `--roles` argument, allowing `takt` to handle default role assignment or execution without a specific role. All work must be delegated.\n\n**`takt` Usage:**\n\n`takt` provides the following key functionalities:\n\n1.  **Starting a New Session:**\n    - `--purpose`: Defines the overall purpose of the session.\n    - `--background`: Provides background context for the session.\n    - `--roles`: Specifies role files to assign to sub-agents (comma-separated).\n    - `--instruction`: The first specific instruction for the sub-agent.\n    - Example: `takt --purpose \"Create a new React component\" --background \"Display user profile\" --roles \"roles/engineer.md\" --instruction \"Create a UserProfile component.\"`\n\n2.  **Continuing a Session:**\n    - `--session <SESSION_ID>`: Specifies the ID of the session to continue.\n    - `--instruction`: A new specific instruction for the sub-agent.\n    - Example: `takt --session <SESSION_ID> --instruction \"Add state management.\"`\n\n3.  **Compressing a Session:**\n    - `--session <SESSION_ID>`: Specifies the ID of the session to compress.\n    - `--compress`: Summarizes the session history to reduce token count.\n    - Example: `takt --session <SESSION_ID> --compress`\n\n4.  **Dry Run Mode:**\n    - `--dry-run`: Reviews the generated JSON prompt without actual execution.\n    - Example: `takt --purpose \"Test Prompt\" --instruction \"My instruction\" --dry-run`\n\n**Key Principles:**\n\n- **STRICT RULE: No Self-Processing:** The Conductor **MUST NEVER** execute any task directly. All processing **MUST BE** delegated to sub-agents exclusively via `takt`. This is a foundational principle of the `pipe` architecture.\n- **Role Handling:** If a specific sub-agent role is provided (e.g., via `@<role_name>` or `--roles`), the Conductor MUST use it. If no specific role is provided, the Conductor MUST call `takt` without the `--roles` argument, allowing `takt` to determine the appropriate handling (e.g., default role, no specific role).\n- **Session Continuation:** Unless explicitly instructed otherwise, the Conductor will continue the current session and add new instructions to the existing session. New sessions are only initiated when clearly directed.\n- **Transparency:** Clearly communicate the execution results of `takt` (including responses from sub-agents) to the user.\n\n---\n\n## Conductor Workflow Flowchart\n\n```mermaid\ngraph TD\n    A[\"Start: Appointed to Conductor Role\"] --> B{\"Is Session ID specified?\"};\n\n    B -- \"Yes\" --> C[\"Execute takt with Session ID and Instruction\"];\n    B -- \"No\" --> D[\"Enter Session ID to continue session, or parameters (--purpose, --background, --instruction, [Optional: --roles]) for a new session\"];\n\n    D --> E{\"Is input a Session ID?\"};\n\n    E -- \"Yes\" --> G{\"Is Session ID valid?\"};\n    E -- \"No\" --> F{\"Is it an instruction to start a new session?\"};\n\n    G -- \"Yes\" --> C;\n    G -- \"No\" --> I[\"Response: Session ID is invalid. Please enter Session ID again\"];\n    I --> D;\n\n    F -- \"Yes\" --> J{\"Are parameters (--purpose, --background, --instruction) clear?\"};\n    F -- \"No\" --> K[\"Response: Please enter Session ID or parameters for a new session\"];\n    K --> D;\n\n    J -- \"Yes\" --> C;\n    J -- \"No\" --> D;\n\n    C --> L{\"What is the next instruction?\"};\n    L -- \"Continue current session\" --> C;\n    L -- \"Another Session ID or New Session\" --> B;\n    L -- \"End\" --> M[\"End\"];\n```\n"
    ]
  },
  "conversation_history": {
    "description": "Historical record of past interactions in this session, in chronological order.",
    "turns": []
  },
  "file_references": {
    "description": "Content of files referenced in the session.",
    "files": [
      {
        "path": "README.md",
        "content": "<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/s-age/pipe/main/src/web/static/images/logo.png\" alt=\"pipe logo\" width=\"200\">\n</p>\n\n[![License: CC0-1.0](https://img.shields.io/badge/License-CC0--1.0-lightgrey.svg)](http://creativecommons.org/publicdomain/zero/1.0/)\n\n# pipe\n\n## Overview\n\n> **Make AI Agents Deterministic.**\n\n`pipe` is an AI agent framework built with deep respect for the **Unix Philosophy**. It shifts the paradigm from \"Conversational AI\" to **AasF (Agent as Function)**.\n\nUnlike traditional frameworks that treat agents as stateful, conversational partners, `pipe` treats an agent as a **stateless, pure function** that accepts structured context via standard input (stdin) and returns execution results via standard output (stdout).\n\n### Philosophy\n\n- **Do One Thing Well:** Each agent role is specialized and acts as a single, deterministic function call.\n- **Composable Intelligence:** Chain agents through natural language instructions via `takt`. A parent agent (e.g., Conductor) delegates tasks to sub-agents, where the output of one agent informs the next through structured session management.\n- **Universal Interface:** Built on text streams (JSON/Markdown), ensuring seamless integration with any CLI tool, script, or CI/CD pipeline.\n\n`pipe` provides a strong foundation for the Agent as Function (AasF) paradigm, enabling smaller contexts by structuring information effectively. It realizes bottom-heavy architecture—where the complexity lies in the well-designed tools and frameworks rather than overburdening the LLM at the top. This is achieved through easy multi-agent orchestration, allowing agents to handle small, specialized tasks and build complex workflows without requiring the LLM to manage everything at once.\n\nFor a deeper dive into the principles of Context Engineering that underpin this philosophy, see our [Wiki article](https://github.com/s-age/pipe/wiki/Context-Engineering:-The-Art-of-Communicating-Intent-to-LLMs).\n\n## Key Concepts\n\n### Mechanism\n\nIn `pipe`, an agent is defined simply as:\n\n$$f(\\text{context}) \\rightarrow \\text{result}$$\n\n`takt` structures and injects precisely crafted context into the LLM. You must explicitly define the `--purpose` and `--background` to ground the agent, ensuring it never hallucinates the goal.\n\n```bash\n# Example: Create a parent session and use its session ID to create a child session\ntakt --purpose \"Simple greeting\" \\\n     --background \"Basic conversation example.\" \\\n     --instruction \"Say hello.\" \\\n| jq -r '.session_id' \\\n| xargs -I {} takt --parent {} \\\n                   --purpose \"Follow-up response\" \\\n                   --background \"A new session that builds on the parent session.\" \\\n                   --instruction \"Respond to the greeting.\"\n```\n\nThis approach leverages `takt`'s options like `--roles` for persona definition, `--instruction` for task specification, and `--parent` for hierarchical session relationships, ensuring modular and composable AI workflows. The output JSON can be piped through tools like `jq` for extraction and chaining, maintaining the deterministic context management central to `pipe`'s philosophy.\n\nThis abstraction enables seamless composition, where any source of structured data can feed into an agent, and agents can chain together or output to any consumer. The philosophy emphasizes composability over monolithic interfaces:\n\n- `cli | agent`: Pipe command-line outputs directly into AI processing.\n- `agent | agent`: Chain agents for multi-step reasoning or specialized workflows.\n- `any script | agent`: Integrate arbitrary scripts or tools as context providers.\n- `WebUI | agent`: Connect web interfaces or APIs to AI orchestration.\n\nThrough `takt`, this becomes a reality—LLM complexity distilled into a Unix-like pipeline of deterministic transformations. Agents consume JSON contexts and produce JSON results, allowing infinite recombination without loss of control.\n\nStop managing complex conversation states. Start composing intelligent functions.\n\n### A Clean Jailbreak from LLM Obfuscation\n\n`pipe` is not another chat agent. It is a tool designed to give you, the developer, complete control over the conversational context. Unlike traditional clients that hide their history management in a black box, `pipe` empowers you to freely manipulate the history, extract what is essential, and achieve **true context engineering**.\n\nThis is a clean jailbreak tool from vendor obfuscation.\n\nWe employ a **minimal yet powerful** CLI-driven approach, focusing on the one thing that truly matters: ensuring the agent understands its purpose, history, and current task without ambiguity.\n\n### Core Philosophy\n\n#### 1. Total Context Control\n\nThe prompt is reconstructed with a structured, self-describing **JSON Schema** for every call. This is inherently more token-efficient and understandable for an LLM. The entire history is transparent, saved in readable JSON session files. This ensures full **auditability** and gives the stateless LLM a persistent, and more importantly, **malleable** memory. You can retry, refine, edit, delete, and compress with surgical precision.\n\n#### 2. Uncompromising Extensibility\n\nBy default, `pipe` is based on `gemini-cli`, but this is merely an implementation detail. The core logic is decoupled. If you want to use the direct API, do it. If you want to use `claude-code`, do it. The framework is designed to be torn apart and rebuilt to your specifications.\n\n#### 3. Git-Inspired Session Management\n\n`pipe`'s session operations are designed with Git's powerful version control concepts in mind, providing developers with familiar and intuitive tools for managing conversational history:\n\n| Operation    | Git Equivalent                             | Description                                                                                                                           |\n| :----------- | :----------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |\n| **Edit**     | `git commit --amend` or `git rebase -i`    | Modify the content of a specific turn or instruction in the session history, allowing for precise refinements without losing context. |\n| **Delete**     | `git reset --hard` or `git rm`             | Remove unwanted turns or entire sections from the session, cleaning up the history for better focus.                                  |\n| **Fork**     | `git branch` or `git fork`                 | Create a new session branch from any point in the conversation, enabling parallel exploration of alternative responses or strategies. |\n| **Compress** | `git rebase --interactive` or `git squash` | Condense long conversation histories into concise summaries, reducing token usage while preserving essential context.                 |\n\nThis Git-inspired approach ensures that session management feels natural to developers, combining the flexibility of version control with the determinism of structured AI interactions.\n\n---\n\n## Features\n\n- **Session-Based History:** Each conversation is a self-contained session, stored in a single, human-readable JSON file.\n- **Structured JSON Prompting:** Builds a detailed, self-describing JSON object as the final prompt, providing meta-context to the model for improved clarity.\n- **CLI-Driven Workflow:** A powerful command-line interface to start, continue, or compress sessions.\n- **Extensible Backend:** The execution agent is decoupled. You can choose between `gemini-api` (direct API calls) and `gemini-cli` (CLI tool) via the `api_mode` setting in `setting.yml`. The architecture allows for swapping in other execution agents as well.\n- **Configuration via YAML:** Configure model, context limits, and other settings in `setting.yml`.\n- **Token-Aware:** Calculates token count for each prompt and warns before exceeding limits.\n- **Dry Run Mode:** A `--dry-run` flag to inspect the final JSON prompt before sending it to the API.\n- **Web UI for Management:** A comprehensive web interface to manage the entire lifecycle of a conversation.\n- **Safe Operations:** Automatic backups are created before any edit or compression operation.\n- **Language Support:** Allows specifying the language for agent responses.\n- **YOLO Mode:** Automatically accept all actions (aka YOLO mode, see [https://www.youtube.com/watch?v=xvFZjo5PgG0](https://www.youtube.com/watch?v=xvFZjo5PgG0) for more details).\n- **In-Session Todos:** Manage a simple todo list directly within the session's metadata.\n- **Advanced Agent-driven Compression**:\n  - A specialized `Compressor` agent can perform **partial compression** on any session's history.\n  - Precisely control the compression by specifying a **turn range**, a **summarization policy** (what to keep), and a **target character count**.\n  - Before applying the compression, a `Reviewer` agent automatically **verifies** that the summarized history maintains a natural conversational flow, preventing context loss.\n  - **Note on MCP Server Setup:** To use advanced features like Compression and Forking, you need to configure the `pipe` MCP server. This applies to both `gemini-cli` and Gemini API modes. In Docker environments, this is typically already set up. For local setups, add the following to your `.gemini/setting.json` (adjust the `workingDir` path to your `pipe` installation):\n    ```json\n    {\n      \"mcpServers\": {\n        \"pipe_tools\": {\n          \"command\": \"python3\",\n          \"args\": [\"-m\", \"pipe.cli.mcp_server\"],\n          \"workingDir\": \"/path/to/pipe\"\n        }\n      }\n    }\n    ```\n  - **Customizing Verification:** If the verification process is too strict and frequently rejects summaries, you can edit `roles/verifier.md` to adjust the approval checklist for more lenient verification. This allows you to balance between context preservation and compression efficiency based on your needs.\n- **Turn-based Forking:** Easily fork a conversation from any specific turn. This allows you to explore alternative responses from the LLM or test different instructions without altering the original history, enabling robust validation and experimentation.\n\nSee [docs/tools.md](docs/tools.md) for information on available tools and integrations.\n\nSee [docs/extending.md](docs/extending.md) for information on extending the framework.\n\n## Advanced Topics\n\n### Git-Inspired Session Management\n\n`pipe`'s session operations are designed with Git's powerful version control concepts in mind, providing developers with familiar and intuitive tools for managing conversational history:\n\n| Operation    | Git Equivalent                             | Description                                                                                                                           |\n| :----------- | :----------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |\n| **Edit**     | `git commit --amend` or `git rebase -i`    | Modify the content of a specific turn or instruction in the session history, allowing for precise refinements without losing context. |\n| **Delete**     | `git reset --hard` or `git rm`             | Remove unwanted turns or entire sections from the session, cleaning up the history for better focus.                                  |\n| **Fork**     | `git branch` or `git fork`                 | Create a new session branch from any point in the conversation, enabling parallel exploration of alternative responses or strategies. |\n| **Compress** | `git rebase --interactive` or `git squash` | Condense long conversation histories into concise summaries, reducing token usage while preserving essential context.                 |\n\nThis Git-inspired approach ensures that session management feels natural to developers, combining the flexibility of version control with the determinism of structured AI interactions.\n\n---\n\n## Installation\n\nSee [docs/setup.md](docs/setup.md) for setup instructions.\n\n## Usage\n\n### Routes to Context Engineering\n\nThe **pipe** framework offers three primary routes, optimized for different user environments and goals, all built on the same structured core.\n\n### 1. Route 1: CLI Script (Automation & CLI)\n\nThis route is ideal for **automation, scripting, and CLI-focused developers** who need reliable, repeatable execution, regardless of the programming language used\u2014as long as you can invoke the `takt` command.\n\n| Use Case               | Description                                                                                                                   |\n| :--------------------- | :---------------------------------------------------------------------------------------------------------------------------- |\n| **Start New Session**  | Define the complete context (`--purpose`, `--background`, `--roles`) and first instruction.                                   |\n| **Continue Session**   | Specify an existing `<SESSION_ID>` and add a new instruction. This is the primary way to give the short-lived agent \"memory.\" |\n| **Compress History**   | Use the `--compress` flag to efficiently replace long history with a summary.                                                 |\n| **Debug/Cost Control** | Use the `--dry-run` flag to inspect the generated JSON prompt before the API call.                                            |\n\n**Examples:**\n\n```bash\n# Start New Session Example\ntakt --purpose \"Create a new React component\" --background \"...\" --roles \"roles/engineer.md\" --instruction \"Create a 'UserProfile' component.\"\n\ntakt --session <SESSION_ID> --instruction \"Now, add a state for loading.\"\n```\n\n### 2. Route 2: Web UI (Management & Human-in-the-Loop)\n\nSee [docs/development.md](docs/development.md) for details on running and using the Web UI.\n\n### 3. Route 3: Execution from Agent (Orchestration)\n\nThis is for **advanced AI system builders** leveraging **pipe's** full context control capabilities for multi-agent coordination.\n\n| Use Case                      | Description                                                                                                                                                                                         |\n| :---------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Role Delegation**           | A parent agent assigns the **Conductor role** to a child agent and delegates the task using the structured command format.                                                                          |\n| **Small-Scale Orchestration** | **By customizing the role definition**, the Conductor role can be programmed to divide complex tasks into subtasks and recursively delegate them to different execution agents with specific roles. |\n| **Clean Execution**           | The delegated task is passed as a **structured JSON prompt**, ensuring maximum efficiency for the short-lived sub-agent.                                                                            |\n\n**Execution Example (Delegation from Parent Agent):**\n\n> **[IMPORTANT] The following command examples are not intended to be executed directly in the user's terminal. They are used as instructions to an already launched parent agent (such as Gemini) to assign the Conductor role and delegate tasks.**\n\n```bash\nAct as @roles/conductor.md takt --session <SESSION_ID> --instruction \"Now, add a state for loading.\"\n```\n\n### 4. Route 4: Agent-driven Workflows (Compression & Verification)\n\nThe easiest way to perform compression is through the Web UI, which provides a dedicated compression interface in the right pane for the currently open session.\n\nThe `pipe` framework supports agent-driven meta-tasks like history management. The `Compressor` and `Reviewer` agents work in tandem to ensure both efficiency and quality.\n\n| Step            | Agent        | Use Case                 | Description                                                                                                                                              |\n| :-------------- | :----------- | :----------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **1. Initiate** | `Compressor` | Surgical Compression     | Start a new session and assign the `roles/compressor.md` role. Instruct this agent to compress parts of _any other session_.                             |\n| **2. Specify**  | `Compressor` | Controlled Summarization | Guide the agent by providing the target `SESSION_ID`, a `START` and `END` turn, a `policy` (what to keep), and a `target length`.                        |\n| **3. Verify**   | `Reviewer`   | Quality Assurance        | Before applying the summary, the `Reviewer` agent is automatically invoked to check if the compressed history flows naturally and preserves key context. |\n| **4. Apply**    | `Compressor` | Finalize Compression     | Once the verification is passed, the agent replaces the specified turn range with the generated summary.                                                 |\n\n**Example (Starting a Compression Session):**\n\n```bash\n# Start a new session to manage other sessions\ntakt --purpose \"Compress a long-running session\" --role \"roles/compressor.md\" --instruction \"I want to compress session <TARGET_SESSION_ID>.\"\n```\n\nThe agent will then interactively guide you through the specification and verification process to perform the compression safely.\n\n### 5. Route 5: Multi-Agent Simulation (e.g., Self-Play)\n\nThe true power of `pipe` is revealed in its ability to facilitate complex multi-agent simulations using nothing more than natural language. By defining roles and procedures in simple Markdown files, you can orchestrate sophisticated interactions between agents.\n\nA compelling demonstration of this is achieving a Reversi game where Gemini plays against itself. This entire simulation is orchestrated by giving a single command to a parent agent.\n\n| Use Case                         | Description                                                                                                                                                    |\n| :------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Self-Play Simulation**         | Instruct an agent to adopt a role and execute a procedure. For example, tell Gemini to act as a Reversi player and follow the game's rules.                    |\n| **Natural Language Programming** | The agents' behaviors are not hard-coded. They are guided entirely by the `@roles` and `@procedures` files you provide, making the system incredibly flexible. |\n\n**Execution Example (Orchestrating a Self-Play Game):**\n\n> **[IMPORTANT]** The following command is an instruction given to a parent AI agent (like Gemini), not meant for direct terminal execution.\n\n```\nAct as @roles/games/reversi_player.md and execute @procedures/reversi_game.md\n```\n\nThis single line of instruction causes the agent to initiate a game of Reversi, playing against itself by following the rules and persona defined in the Markdown files. This showcases the framework's capability for complex task delegation and agent-based automation, all orchestrated through simple, human-readable text.\n\n## Advanced Topics\n\n### Compression & Verification Workflow\n\n## Examples\n\n### Dry Run Output Example\n\nWhen running `takt` with the `--dry-run` flag, the generated JSON prompt is displayed. This JSON object represents the structured input that would be sent to the AI sub-agent. It can be useful for understanding how `pipe` constructs its prompts or for direct experimentation with AI models.\n\nHere's an example of a generated prompt:\n\nNote that the JSON presented here is pretty-printed for readability; the actual output from `takt --dry-run` is also pretty-printed with indentation for human readability.\n\n````json\n{\n  \"description\": \"This structured prompt guides your response. First, understand the core instructions: `main_instruction` defines your thinking process. Next, identify the immediate objective from `current_task` and `todos`. Then, gather all context required to execute the task by processing `session_goal`, `roles`, `constraints`, `conversation_history`, and `file_references` in that order. Finally, execute the `current_task` by synthesizing all gathered information.\",\n  \"main_instruction\": \"Your main instruction is to be helpful and follow all previous instructions.\",\n  \"reasoning_process\": {\n    \"description\": \"Think step-by-step to achieve the goal.\"\n  },\n  \"current_task\": {\n    \"type\": \"model_response\",\n    \"instruction\": null,\n    \"response\": null,\n    \"name\": null,\n    \"content\": \"Setup is complete. Awaiting the next command.\\n\",\n    \"original_turns_range\": null,\n    \"timestamp\": \"2025-10-26T20:36:04.540328+09:00\"\n  },\n  \"todos\": [\n    {\n      \"title\": \"test1\",\n      \"description\": \"\",\n      \"checked\": false\n    },\n    {\n      \"title\": \"test2\",\n      \"description\": \"\",\n      \"checked\": false\n    }\n  ],\n  \"current_datetime\": \"2025-10-26T20:36:51.067644+09:00\",\n  \"session_goal\": {\n    \"description\": \"This section outlines the goal of the current session.\",\n    \"purpose\": \"Generate dry-run output for README\",\n    \"background\": \"To demonstrate the prompt structure in the project's main README file.\"\n  },\n  \"roles\": {\n    \"description\": \"The following are the roles for this session.\",\n    \"definitions\": [\n      \"**Role: Conductor**\\n\\n**Responsibilities:**\\n\\nThe primary responsibility of any agent assigned the Conductor role is to **EXCLUSIVELY** delegate tasks to sub-agents via `takt`. The Conductor **MUST NEVER** perform any processing directly. Instead, the Conductor constructs and executes appropriate `takt` commands based on the provided instructions and session context. If a specific role is not provided, the Conductor should call `takt` without the `--roles` argument, allowing `takt` to handle default role assignment or execution without a specific role. All work must be delegated.\\n\\n**`takt` Usage:**\\n\\n`takt` provides the following key functionalities:\\n\\n1.  **Starting a New Session:**\\n    *   `--purpose`: Defines the overall purpose of the session.\\n    *   `--background`: Provides background context for the session.\\n    *   `--roles`: Specifies role files to assign to sub-agents (comma-separated).\\n    *   `--instruction`: The first specific instruction for the sub-agent.\\n    *   Example: `takt --purpose \\\"Create a new React component\\\" --background \\\"Display user profile\\\" --roles \\\"roles/engineer.md\\\" --instruction \\\"Create a UserProfile component.\\\"`\\n\\n2.  **Continuing a Session:**\\n    *   `--session <SESSION_ID>`: Specifies the ID of the session to continue.\\n    *   `--instruction`: A new specific instruction for the sub-agent.\\n    *   Example: `takt --session <SESSION_ID> --instruction \\\"Add state management.\\\"`\\n\\n3.  **Compressing a Session:**\\n    *   `--session <SESSION_ID>`: Specifies the ID of the session to compress.\\n    *   `--compress`: Summarizes the session history to reduce token count.\\n    *   Example: `takt --session <SESSION_ID> --compress`\\n\\n4.  **Dry Run Mode:**\\n    *   `--dry-run`: Reviews the generated JSON prompt without actual execution.\\n    *   Example: `takt --purpose \\\"Test Prompt\\\" --instruction \\\"My instruction\\\" --dry-run`\\n\\n**Key Principles:**\\n\n*   **STRICT RULE: No Self-Processing:** The Conductor **MUST NEVER** execute any task directly. All processing **MUST BE** delegated to sub-agents exclusively via `takt`. This is a foundational principle of the `pipe` architecture.\\n*   **Role Handling:** If a specific sub-agent role is provided (e.g., via `@<role_name>` or `--roles`), the Conductor MUST use it. If no specific role is provided, the Conductor MUST call `takt` without the `--roles` argument, allowing `takt` to determine the appropriate handling (e.g., default role, no specific role).\\n*   **Session Continuation:** Unless explicitly instructed otherwise, the Conductor will continue the current session and add new instructions to the existing session. New sessions are only initiated when clearly directed.\\n*   **Transparency:** Clearly communicate the execution results of `takt` (including responses from sub-agents) to the user.\\n\\n---\\n\\n## Conductor Workflow Flowchart\\n\\n```mermaid\\ngraph TD\\n    A[\\\"Start: Appointed to Conductor Role\\\"] --> B{\\\"Is Session ID specified?\\\"};\\n\\n    B -- \\\"Yes\\\" --> C[\\\"Execute takt with Session ID and Instruction\\\"];\\n    B -- \\\"No\\\" --> D[\\\"Enter Session ID to continue session, or parameters (--purpose, --background, --instruction, [Optional: --roles]) for a new session\\\"];\\n\\n    D --> E{\\\"Is input a Session ID?\\\"};\\n\\n    E -- \\\"Yes\\\" --> G{\\\"Is Session ID valid?\\\"};\\n    E -- \\\"No\\\" --> F{\\\"Is it an instruction to start a new session?\\\"};\\n\n    G -- \\\"Yes\\\" --> C;\\n    G -- \\\"No\\\" --> I[\\\"Response: Session ID is invalid. Please enter Session ID again\\\"];\\n    I --> D;\\n\n    F -- \\\"Yes\\\" --> J{\\\"Are parameters (--purpose, --background, --instruction) clear?\\\"};\\n    F -- \\\"No\\\" --> K[\\\"Response: Please enter Session ID or parameters for a new session\\\"];\\n    K --> D;\\n\n    J -- \\\"Yes\\\" --> C;\\n    J -- \\\"No\\\" --> D;\\n\n    C --> L{\\\"What is the next instruction?\\\"};\\n    L -- \\\"Continue current session\\\" --> C;\\n    L -- \\\"Another Session ID or New Session\\\" --> B;\\n    L -- \\\"End\\\" --> M[\\\"End\\\"];\\n```\"\n    ]\n  },\n  \"constraints\": {\n    \"description\": \"Constraints for the model.\",\n    \"language\": \"japanese\",\n    \"processing_config\": {\n      \"description\": \"Configuration for processing.\",\n      \"multi_step_reasoning_active\": true\n    },\n    \"hyperparameters\": {\n      \"description\": \"Hyperparameter settings for the model.\",\n      \"temperature\": {\n        \"type\": \"number\",\n        \"value\": 0.2,\n        \"description\": \"Be precise and factual. A lower value is preferred for deterministic output.\"\n      },\n      \"top_p\": {\n        \"type\": \"number\",\n        \"value\": 0.5,\n        \"description\": \"Consider a broad range of possibilities, but adhere strictly to the temperature setting.\"\n      },\n      \"top_k\": {\n        \"type\": \"number\",\n        \"value\": 5.0,\n        \"description\": \"Limit the generation to the top 5 most likely tokens at each step.\"\n      }\n    }\n  },\n  \"conversation_history\": {\n    \"description\": \"Historical record of past interactions in this session, in chronological order.\",\n    \"turns\": [\n      {\n        \"type\": \"user_task\",\n        \"instruction\": \"This is the initial instruction to set up the session.\",\n        \"timestamp\": \"2025-10-26T20:35:58.210075+09:00\"\n      }\n    ]\n  },\n  \"file_references\": [\n    {\n      \"path\": \"foo.txt\",\n      \"content\": \"bar\"\n    }\n  ]\n}\n````\n\n## License\n\n### The Spirit of the Jailbreak\n\nThis project's _original code_ is released under the [CC0 1.0 Universal (CC0 1.0) Public Domain Dedication](https://creativecommons.org/publicdomain/zero/1.0/).\n\nCustomize it as you wish. Jailbreak as you desire.\n\n**Important Note on Dependencies:**\nThis project utilizes various third-party libraries, each governed by its own license. While the original code of `pipe` is dedicated to the public domain under CC0, the licenses of these dependencies (e.g., MIT, Apache 2.0, BSD) still apply to their respective components.\n\n- **Commercial Use**: Please review the licenses of all included third-party libraries to ensure compliance with your intended use, especially for commercial applications.\n- **Attribution**: Some third-party libraries may require attribution. It is your responsibility to comply with all applicable license terms.\n\nThe purpose of this project is to be a **pipe to the agent**, and a **pipe to our followers** (the community).\n"
      }
    ]
  },
  "current_task": {
    "description": "The specific task that the AI sub-agent must currently execute.",
    "instruction": "Your main instruction is to be helpful and follow all previous instructions."
  },
  "current_datetime": "2025-11-29T17:18:31.983455+09:00"
}
