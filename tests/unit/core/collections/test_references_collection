from unittest.mock import MagicMock, patch

import pytest
from pipe.core.collections.references import ReferenceCollection

from tests.factories.models.reference_factory import ReferenceFactory


class TestReferenceCollection:
    """Tests for ReferenceCollection."""

    @pytest.fixture
    def collection(self):
        """Fixture for an empty ReferenceCollection."""
        return ReferenceCollection()

    def test_init_empty(self):
        """Test initialization with no data."""
        col = ReferenceCollection()
        assert len(col) == 0
        assert col.default_ttl == 3

    def test_init_with_data(self):
        """Test initialization with existing data."""
        refs = [
            ReferenceFactory.create(path="a.py", ttl=5),
            ReferenceFactory.create(path="b.py", ttl=2),
        ]
        col = ReferenceCollection(data=refs, default_ttl=10)
        assert len(col) == 2
        assert col.default_ttl == 10
        # Should be sorted by TTL desc
        assert col[0].path == "a.py"
        assert col[1].path == "b.py"

    def test_add_new(self, collection):
        """Test adding a new reference."""
        collection.add("test.py")
        assert len(collection) == 1
        assert collection[0].path == "test.py"
        assert collection[0].ttl == 3
        assert not collection[0].disabled

    def test_add_duplicate(self, collection):
        """Test adding a duplicate reference (should be ignored)."""
        collection.add("test.py")
        collection.add("test.py")
        assert len(collection) == 1

    def test_update_ttl(self, collection):
        """Test updating TTL by path."""
        collection.add("test.py")
        collection.update_ttl("test.py", 10)
        assert collection[0].ttl == 10
        assert not collection[0].disabled

    def test_update_ttl_disable(self, collection):
        """Test updating TTL to 0 or less disables the reference."""
        collection.add("test.py")
        collection.update_ttl("test.py", 0)
        assert collection[0].ttl == 0
        assert collection[0].disabled

    def test_sort_by_ttl(self):
        """Test sorting logic: active first, then TTL desc, then disabled."""
        refs = [
            ReferenceFactory.create(path="disabled_high.py", ttl=10, disabled=True),
            ReferenceFactory.create(path="active_low.py", ttl=1, disabled=False),
            ReferenceFactory.create(path="active_high.py", ttl=5, disabled=False),
        ]
        col = ReferenceCollection(data=refs)
        # Expected order: active_high (5), active_low (1), disabled_high (10)
        assert col[0].path == "active_high.py"
        assert col[1].path == "active_low.py"
        assert col[2].path == "disabled_high.py"

    def test_sort_by_ttl_with_none(self):
        """Test sorting logic when TTL is None (uses default_ttl)."""
        col = ReferenceCollection(default_ttl=5)
        col.data = [
            ReferenceFactory.create(path="none.py", ttl=None, disabled=False),
            ReferenceFactory.create(path="low.py", ttl=2, disabled=False),
        ]
        col.sort_by_ttl()
        # none.py (5) > low.py (2)
        assert col[0].path == "none.py"
        assert col[1].path == "low.py"

    @patch("pipe.core.domains.references.get_active_references")
    def test_get_for_prompt_success(self, mock_get_active, collection):
        """Test get_for_prompt yields content for active references."""
        ref = ReferenceFactory.create(path="test.py")
        mock_get_active.return_value = [ref]

        mock_repo = MagicMock()
        mock_repo.read_text.return_value = "file content"

        project_root = "/project"

        # Mock os.path functions to ensure they behave predictably
        with (
            patch("os.path.abspath", side_effect=lambda x: x),
            patch("os.path.join", side_effect=lambda *args: "/".join(args)),
            patch("os.path.commonpath", return_value="/project"),
        ):
            results = list(collection.get_for_prompt(mock_repo, project_root))

            assert len(results) == 1
            assert results[0] == {"path": "test.py", "content": "file content"}
            mock_repo.read_text.assert_called_once_with(
                "/project/test.py", project_root
            )

    @patch("pipe.core.domains.references.get_active_references")
    @patch("pipe.core.collections.references.logger")
    def test_get_for_prompt_outside_root(
        self, mock_logger, mock_get_active, collection
    ):
        """Test get_for_prompt skips files outside project root."""
        ref = ReferenceFactory.create(path="../outside.py")
        mock_get_active.return_value = [ref]

        mock_repo = MagicMock()
        project_root = "/project"

        # Mock os.path.commonpath to simulate outside root
        # commonpath([project_root]) -> /project
        # commonpath([project_root, full_path]) -> /
        def mock_commonpath(paths):
            if len(paths) == 1:
                return "/project"
            return "/"

        with (
            patch("os.path.abspath", side_effect=lambda x: x),
            patch("os.path.join", side_effect=lambda *args: "/".join(args)),
            patch("os.path.commonpath", side_effect=mock_commonpath),
        ):
            results = list(collection.get_for_prompt(mock_repo, project_root))

            assert len(results) == 0
            mock_logger.warning.assert_called()
            assert "outside the project root" in mock_logger.warning.call_args[0][0]

    @patch("pipe.core.domains.references.get_active_references")
    @patch("pipe.core.collections.references.logger")
    def test_get_for_prompt_not_found(self, mock_logger, mock_get_active, collection):
        """Test get_for_prompt handles missing files."""
        ref = ReferenceFactory.create(path="missing.py")
        mock_get_active.return_value = [ref]

        mock_repo = MagicMock()
        mock_repo.read_text.return_value = None

        project_root = "/project"

        with (
            patch("os.path.abspath", side_effect=lambda x: x),
            patch("os.path.join", side_effect=lambda *args: "/".join(args)),
            patch("os.path.commonpath", return_value="/project"),
        ):
            results = list(collection.get_for_prompt(mock_repo, project_root))

            assert len(results) == 0
            mock_logger.warning.assert_called()
            assert (
                "not found or could not be read" in mock_logger.warning.call_args[0][0]
            )

    @patch("pipe.core.domains.references.get_active_references")
    @patch("pipe.core.collections.references.logger")
    def test_get_for_prompt_file_not_found_exception(
        self, mock_logger, mock_get_active, collection
    ):
        """Test get_for_prompt handles FileNotFoundError."""
        ref = ReferenceFactory.create(path="error.py")
        mock_get_active.return_value = [ref]

        mock_repo = MagicMock()
        mock_repo.read_text.side_effect = FileNotFoundError("File not found")

        project_root = "/project"

        with (
            patch("os.path.abspath", side_effect=lambda x: x),
            patch("os.path.join", side_effect=lambda *args: "/".join(args)),
            patch("os.path.commonpath", return_value="/project"),
        ):
            results = list(collection.get_for_prompt(mock_repo, project_root))

            assert len(results) == 0
            mock_logger.warning.assert_called()
            assert (
                "Could not process reference file"
                in mock_logger.warning.call_args[0][0]
            )

    @patch("pipe.core.domains.references.get_active_references")
    @patch("pipe.core.collections.references.logger")
    def test_get_for_prompt_exception(self, mock_logger, mock_get_active, collection):
        """Test get_for_prompt handles general exceptions."""
        ref = ReferenceFactory.create(path="error.py")
        mock_get_active.return_value = [ref]

        mock_repo = MagicMock()
        mock_repo.read_text.side_effect = Exception("Unexpected error")

        project_root = "/project"

        with (
            patch("os.path.abspath", side_effect=lambda x: x),
            patch("os.path.join", side_effect=lambda *args: "/".join(args)),
            patch("os.path.commonpath", return_value="/project"),
        ):
            results = list(collection.get_for_prompt(mock_repo, project_root))

            assert len(results) == 0
            mock_logger.warning.assert_called()
            assert (
                "Could not process reference file"
                in mock_logger.warning.call_args[0][0]
            )

    @patch("pipe.core.domains.references.decrement_all_references_ttl")
    def test_decrement_all_ttl(self, mock_decrement, collection):
        """Test decrement_all_ttl delegates to domain function."""
        collection.decrement_all_ttl()
        mock_decrement.assert_called_once_with(collection)

    def test_update_ttl_by_index(self, collection):
        """Test updating TTL by index."""
        collection.add("test.py")
        collection.update_ttl_by_index(0, 5)
        assert collection[0].ttl == 5
        assert not collection[0].disabled

    def test_update_ttl_by_index_out_of_range(self, collection):
        """Test update_ttl_by_index raises IndexError for invalid index."""
        with pytest.raises(IndexError):
            collection.update_ttl_by_index(0, 5)

    def test_update_persist_by_index(self, collection):
        """Test updating persist state by index."""
        collection.add("test.py")
        collection.update_persist_by_index(0, True)
        assert collection[0].persist is True

    def test_update_persist_by_index_out_of_range(self, collection):
        """Test update_persist_by_index raises IndexError for invalid index."""
        with pytest.raises(IndexError):
            collection.update_persist_by_index(0, True)

    def test_toggle_disabled_by_index(self, collection):
        """Test toggling disabled state by index."""
        collection.add("test.py")
        assert not collection[0].disabled

        new_state = collection.toggle_disabled_by_index(0)
        assert new_state is True
        assert collection[0].disabled is True

        new_state = collection.toggle_disabled_by_index(0)
        assert new_state is False
        assert not collection[0].disabled

    def test_toggle_disabled_by_index_out_of_range(self, collection):
        """Test toggle_disabled_by_index raises IndexError for invalid index."""
        with pytest.raises(IndexError):
            collection.toggle_disabled_by_index(0)

    def test_pydantic_serialization(self):
        """Test Pydantic serialization of ReferenceCollection."""
        from pydantic import BaseModel

        class MockModel(BaseModel):
            refs: ReferenceCollection

        refs = [
            ReferenceFactory.create(path="a.py", ttl=3),
            ReferenceFactory.create(path="b.py", ttl=1),
        ]
        col = ReferenceCollection(data=refs)
        model = MockModel(refs=col)

        dump = model.model_dump()
        assert isinstance(dump["refs"], list)
        assert len(dump["refs"]) == 2
        assert dump["refs"][0]["path"] == "a.py"

    def test_pydantic_validation(self):
        """Test Pydantic validation of ReferenceCollection."""
        from pydantic import BaseModel

        class MockModel(BaseModel):
            refs: ReferenceCollection

        data = {
            "refs": [
                {"path": "a.py", "ttl": 3},
                {"path": "b.py", "ttl": 1},
            ]
        }
        model = MockModel.model_validate(data)
        assert isinstance(model.refs, ReferenceCollection)
        assert len(model.refs) == 2
        assert model.refs[0].path == "a.py"

        # Test validation from instance
        model2 = MockModel.model_validate(model)
        assert model2.refs == model.refs

    def test_pydantic_json_schema(self):
        """Test Pydantic JSON schema generation for ReferenceCollection."""
        from pydantic import BaseModel

        class MockModel(BaseModel):
            refs: ReferenceCollection

        schema = MockModel.model_json_schema()
        assert schema["properties"]["refs"]["type"] == "array"
        assert "items" in schema["properties"]["refs"]
